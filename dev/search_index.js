var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = QEDprocesses","category":"page"},{"location":"#QEDprocesses","page":"Home","title":"QEDprocesses","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for QEDprocesses.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [QEDprocesses]","category":"page"},{"location":"#QEDprocesses.AbstractComputationSetup","page":"Home","title":"QEDprocesses.AbstractComputationSetup","text":"Abstract base type for computation setups.  A setup means a collection of setup data needed to evaluate a dedicated quantity of given running data. Therefore, each setup is associated with a single quantity, which one may compute using the setup data and the running data.  Despite that, the decomposition into setup and running data is arbitrary, and this can be used for cases where a subset of the variables a quantity depends on is kept constant. \n\nnote: Computation setup interface\nThe computation performed using a computation setup is separated into three steps:1. input validation\n2. actual computation\n3. post processingwhere every step has its own interface function (see compute for details). Input validationEvery subtype of AbstractComputationSetup should implement the interface function_assert_valid_input(stp::AbstractComputationSetup, input)which should throw and an exception subtyped from AbstractInvalidInputException if the input is not valid for the computation of the associated quantity (see _assert_valid_input for more details).  The default implementation does nothing, i.e. every input is valid by default. Provide a custom implementation if a different behavior is required.Actual computationEvery subtype of AbstractComputationSetup must at least implement the required interface function_compute(stp::AbstractComputationSetup, input) which computes the value of the associated quantity for a given input (see _compute for more details).Post processingEvery subtype of AbstractComputationSetup should implement the interface function_post_processing(stp::AbstractComputationSetup, input, result) which performs task after the actual computation, e.g. conversions or normalizations (see _post_processing for more details).\n\n\n\n\n\n","category":"type"},{"location":"#QEDprocesses.AbstractInvalidInputException","page":"Home","title":"QEDprocesses.AbstractInvalidInputException","text":"Abstract base type for exceptions indicating invalid input. See InvalidInputError for a simple concrete implementation.  Concrete implementations should at least implement \n\n\nBase.showerror(io::IO, err::CustomInvalidError) where {CustomInvalidError<:AbstractInvalidInputException}\n\n\n\n\n\n\n","category":"type"},{"location":"#QEDprocesses.AbstractModelDefinition","page":"Home","title":"QEDprocesses.AbstractModelDefinition","text":"Abstract base type for all compute model definitions in the context of scattering processes. Every subtype of AbstractModelDefinition is associated with a fundamental interaction.  Therefore, one needs to implement the following soft interface function\n\nfundamental_interaction_type(::AbstractModelDefinition)\n\n\n\n\n\n","category":"type"},{"location":"#QEDprocesses.AbstractProcessDefinition","page":"Home","title":"QEDprocesses.AbstractProcessDefinition","text":"Abstract base type for definitions of scattering processes. It is the root type for the  process interface, which assumes that every subtype of AbstractProcessDefinition implements at least \n\nincoming_particles(proc_def::AbstractProcessDefinition)\noutgoing_particles(proc_def::AbstractProcessDefinition)\n\nwhich return a tuple of the incoming and outgoing particles, respectively.\n\n\n\n\n\n","category":"type"},{"location":"#QEDprocesses.AbstractProcessSetup","page":"Home","title":"QEDprocesses.AbstractProcessSetup","text":"Abstract base type for setups related to combining scattering processes and physical models.   Every subtype of AbstractProcessSetup must implement at least the following  interface functions:\n\nscattering_process(::AbstractProcessSetup) \nphysical_model(::AbstractProcessSetup) \n\nDerived from these interface functions, the following delegations are provided:\n\nnumber_incoming_particles(::AbstractProcessSetup)\nnumber_outgoing_particles(::AbstractProcessSetup)\n\n\n\n\n\n","category":"type"},{"location":"#QEDprocesses.InvalidInputError","page":"Home","title":"QEDprocesses.InvalidInputError","text":"InvalidInputError(msg::String)\n\nException which is thrown if a given input is invalid, e.g. passed to _assert_valid_input.\n\n\n\n\n\n","category":"type"},{"location":"#QEDprocesses._assert_valid_input-Tuple{AbstractComputationSetup, Any}","page":"Home","title":"QEDprocesses._assert_valid_input","text":"_assert_valid_input(stp::AbstractComputationSetup, input::Any)\n\nInterface function, which asserts that the given input is valid, and throws an InvalidInputError if not.\n\nnote: default implementation\nBy default, every input is assumed to be valid. Therefore, this function does nothing.  To customize this behavior, add your own implementation of_assert_valid_input(stp::YourCustomSetup,input)which should throw an exception, which is a subtype of AbstractInvalidInputException. One may also use the concrete implementation InvalidInputError if the input is invalid instead of writing a custom exception type.\n\n\n\n\n\n","category":"method"},{"location":"#QEDprocesses._base_component_type-Union{Tuple{AbstractArray{LV}}, Tuple{LV}} where LV<:QEDbase.AbstractLorentzVector","page":"Home","title":"QEDprocesses._base_component_type","text":"_base_component_type(array_of_lv::AbstractArray{LV}) where {LV<:QEDbase.AbstractLorentzVector}\n\nReturn the type of the components of given Lorentz vectors, which are by themself elements of an  AbstractArray.\n\nExamples\n\njulia> using QEDbase\njulia> using QEDprocesses\njulia> v = Vector{SFourMomentum}(undef,10)\njulia> QEDprocesses._base_component_type(v)\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"#QEDprocesses._compute","page":"Home","title":"QEDprocesses._compute","text":"_compute(stp::AbstractComputationSetup, input::Any)\n\nInterface function that returns the value of the associated quantity evaluated on input, which can be anything the associated quantity is defined to be feasible for.\n\nnote: unsafe implementation\nThis function must be implemented for any subtype of AbstractComputationSetup. It should not do any input validation or post processing (see _assert_valid_input and _post_processing), as those two are performed while calling  the safe version of this function compute.\n\n\n\n\n\n","category":"function"},{"location":"#QEDprocesses._differential_cross_section","page":"Home","title":"QEDprocesses._differential_cross_section","text":"_differential_cross_section(\n    proc_def::AbstractProcessDefinition,\n    model_def::AbstractModelDefinition,\n    in_phasespace::AbstractVector{T},\n    out_phasespace::AbstractVector{T},\n) where {T<:QEDbase.AbstractFourMomentum}\n\nInterface function for the combination of scattering processes and physical models. Return the differential cross section of a  given process and physical model for a passed initial and final phase space. The elements of the AbstractVector representing the phase spaces  are the momenta of the respective particles. The implementation of this function for a concrete process and model must not  check if the length of the passed phase spaces match the respective number of particles. \n\nnote: differential cross section interface\nGiven an implementation of this method, the following unsafe generic implementations are provided:\n_differential_cross_section(proc_def,model_def,in_phasespace::AbstractVector{T},finial_phasespace::AbstractMatrix{T})\n_differential_cross_section(proc_def,model_def,in_phasespace::AbstractMatrix{T},finial_phasespace::AbstractVector{T})\n_differential_cross_section(proc_def,model_def,in_phasespace::AbstractMatrix{T},finial_phasespace::AbstractMatrix{T})\nwhere T<:QEDbase.AbstractFourMomentum. Although, any combinations of initial and final phase space types given by single set of points (AbstractVector{T}) and mutiple set of points (AbstractMatrix{T})  is implemented. Furthermore, a safe version of _differential_cross_section is also implemented: differential_cross_section.\n\nnote: unsafe implementation\nEach instance of this function does not check the validity of the input.  Therefore, these functions are not exported and should be used with caution. To add a method in order to implement the cross section interface,  it is recommented to directly use QEDprocesses._differential_cross_section instead of globally using QEDprocesses: _differential_cross_section.\n\n\n\n\n\n","category":"function"},{"location":"#QEDprocesses._post_processing-Tuple{AbstractComputationSetup, Any, Any}","page":"Home","title":"QEDprocesses._post_processing","text":"function _post_processing(stp::AbstractComputationSetup, input::Any, result::Any)\n\nInterface function, which is called in compute after _compute has been called. This function is dedicated to  finalize the result of a computation. \n\nnote: default implementation\nSince in the case of no post processing the result of _compute is unchanged, this function returns result by default.\n\n\n\n\n\n","category":"method"},{"location":"#QEDprocesses._total_cross_section","page":"Home","title":"QEDprocesses._total_cross_section","text":"_total_cross_section(\n    proc_def::AbstractProcessDefinition,\n    model_def::AbstractModelDefinition,\n    in_phasespace::AbstractVector{T},\n) where {T<:QEDbase.AbstractFourMomentum} end\n\nInterface function for the combination of scattering processes and physical models. Return the total cross section of a  given process and model for a passed initial phase space. The elements of the AbstractVector representing the initial phase space are the momenta of the respective particles. The implementation of this function for a concrete process and model must not  check if the length of the passed initial phase spaces match number of incoming particles. \n\nnote: cross section interface\nGiven an implementation of this method, the following unsafe generic implementation is provided:\n_total_cross_section(proc_def,model_def,in_phasespace::AbstractMatrix{T})\nwhere T<:QEDbase.AbstractFourMomentum. Although, _total_cross_section is also implemented for a vector of initial phase space points. Furthermore, a safe version of _total_cross_section is also implemented: total_cross_section.\n\nnote: Note\nEach instance of this function does not check the validity of the input.  This function is not exported and should be used with caution. To add a method in order to implement the cross section interface,  it is recommented to directly use QEDprocesses._total_cross_section instead of globally using QEDprocesses: _total_cross_section.\n\n\n\n\n\n","category":"function"},{"location":"#QEDprocesses.compute-Tuple{AbstractComputationSetup, Any}","page":"Home","title":"QEDprocesses.compute","text":"compute(stp::AbstractComputationSetup, input::Any)\n\nReturn the value of the quantity associated with stp for a given input.  In addition to the actual call of the associated unsafe version _compute, input validation ([_assert_valid_input]) and post processing  (using _post_processing) are wrapped around the calculation (see AbstractComputationSetup for details).\n\n\n\n\n\n","category":"method"},{"location":"#QEDprocesses.differential_cross_section-Union{Tuple{T}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractVecOrMat{T}, AbstractVecOrMat{T}}} where T<:QEDbase.AbstractFourMomentum","page":"Home","title":"QEDprocesses.differential_cross_section","text":"differential_cross_section(\n    proc_def::AbstractProcessDefinition,\n    model_def::AbstractModelDefinition,\n    in_phasespace::Union{AbstractVector{T},AbstractMatrix{T}},\n    out_phasespace::Union{AbstractVector{T},AbstractMatrix{T}},\n) where {T<:QEDbase.AbstractFourMomentum}\n\nReturn the differential cross section for a given combination of a scattering process  and model definition evaluated on the passed inital and final phase space points. \n\nThis function will eventually call the respective interface function _differential_cross_section.\n\n\n\n\n\n","category":"method"},{"location":"#QEDprocesses.fundamental_interaction_type","page":"Home","title":"QEDprocesses.fundamental_interaction_type","text":"fundamental_interaction_type(models_def::AbstractModelDefinition)\n\nReturn the fundamental interaction associated with the passed model definition.\n\n\n\n\n\n","category":"function"},{"location":"#QEDprocesses.incoming_particles","page":"Home","title":"QEDprocesses.incoming_particles","text":"incoming_particles(proc_def::AbstractProcessDefinition)\n\nInterface function for scattering processes. Return a tuple of the incoming particles for the given process definition. This function needs to be given to implement the scattering process interface.\n\n\n\n\n\n","category":"function"},{"location":"#QEDprocesses.number_incoming_particles-Tuple{AbstractProcessDefinition}","page":"Home","title":"QEDprocesses.number_incoming_particles","text":"number_incoming_particles(proc_def::AbstractProcessDefinition)\n\n\nReturn the number of incoming particles of a given process. \n\n\n\n\n\n","category":"method"},{"location":"#QEDprocesses.number_outgoing_particles-Tuple{AbstractProcessDefinition}","page":"Home","title":"QEDprocesses.number_outgoing_particles","text":"number_outgoing_particles(proc_def::AbstractProcessDefinition)\n\n\nReturn the number of outgoing particles of a given process. \n\n\n\n\n\n","category":"method"},{"location":"#QEDprocesses.outgoing_particles","page":"Home","title":"QEDprocesses.outgoing_particles","text":"outgoing_particles(proc_def::AbstractProcessDefinition)\n\nInterface function for scattering processes. Return the tuple of outgoing particles for the given process definition. This function needs to be given to implement the scattering process interface.\n\n\n\n\n\n","category":"function"},{"location":"#QEDprocesses.physical_model","page":"Home","title":"QEDprocesses.physical_model","text":"physical_model(stp::AbstractProcessSetup)\n\nInterface function that returns the physical model associated with stp, i.e. an object which is a subtype of AbstractModelDefinition.\n\n\n\n\n\n","category":"function"},{"location":"#QEDprocesses.scattering_process","page":"Home","title":"QEDprocesses.scattering_process","text":"scattering_process(stp::AbstractProcessSetup)\n\nInterface function that returns the scattering process associated with stp, i.e. an object which is a subtype of AbstractProcessDefinition. \n\n\n\n\n\n","category":"function"},{"location":"#QEDprocesses.total_cross_section-Union{Tuple{T}, Tuple{AbstractProcessDefinition, AbstractModelDefinition, AbstractVecOrMat{T}}} where T<:QEDbase.AbstractFourMomentum","page":"Home","title":"QEDprocesses.total_cross_section","text":"total_cross_section(\n    proc_def::AbstractProcessDefinition,\n    model_def::AbstractModelDefinition,\n    in_phasespace::Union{AbstractVector{T},AbstractMatrix{T}},\n) where {T<:QEDbase.AbstractFourMomentum}\n\nReturn the total cross section for a combination of a scattering process and a physical model evaluated on a given initial phase space. \n\nThis function will eventually call the respective interface function _total_cross_section.\n\n\n\n\n\n","category":"method"}]
}
